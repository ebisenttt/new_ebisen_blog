---
title: "ダイクストラ法"
date: '2023-09-02T10:30:31+09:00'
---
## 🤔 何が書いてあるの？
- ダイクストラ（Dijkstra）法の実装方法と特徴についてまとめる

## 🤔 何が大事なの？
- 優先度付きキューを使うことで，「探索済み」=「最短距離確定済み」となること．
- キューから取り出したときに最短距離を確定させること．

## 🤔 ダイクストラ法ってなに？
- グラフ上の2頂点間の最短距離を求めるアルゴリズム
- 幅優先探索，深さ優先探索は辺の長さが固定の場合，01-BFSは辺の長さが2値の場合に用いるのに対し，ダイクストラ法は辺の長さが任意の非負整数の場合に用いることができる
- 優先度付きキューを使って実装するのが一般的

## 🤔 どういう仕組み？
### 優先度付きキュー
スタックは後入れ先出し（LIFO），キューは先入れ先出し（FIFO）と，入れた順番で出す順番が決まる．優先度付きキューは，入れた要素の値の大きさによって順番が決まる．具体的には，要素の昇順または降順になるように入れる．要素を入れる際，順番決めに二分探索を使うので，O(logN)の計算量がかかる．
### 最短距離を記録する配列
始点から頂点`i`への**最短距離**`d`を記録するための配列`dist`を用意しておく．このとき`dist[i]=d`となる．なお，各要素の初期値は`-1`とするこれにより，

- `dist[i] == -1` : 始点から頂点`i`への最短距離はまだ確定していない
- `dist[i] != -1` : 始点から頂点`i`への最短距離`dist[i]`で確定済み

と表現できる
### 始点から近い順に頂点を探索する
「始点から頂点番号`i`へ距離`d`で到達できる経路がある」とわかったら，優先度付きキューに `(始点からの距離d, 頂点番号i)`というタプルを入れる．優先度付きキューは，デフォルトでタプルを昇順に並べるので，キューの先頭ほど始点からの距離が近い頂点の情報が記録されている状態が保持される．
### 取り出した頂点への距離を確認・記録する
優先度付きキューの先頭のタプルを取り出す．これを`(始点からの距離d, 頂点番号i)`とする．このとき

- `dist[i] == -1` : 始点から頂点`i`への最短距離が決まっていないので`dist[i] = d`とする
- `dist[i] != -1` : 始点から頂点`i`への最短距離は決まっているので何もしない

とする．なお，頂点`i`への最短距離を記録した後により短い最短距離が見つかることはない．なぜなら，もしそのような最短距離があるのであれば，優先度付きキューの並び替える機能によってそちらが先に取り出され，その時点で既に最短距離が記録されているはずだからである．つまり，「初めて最短距離が記録されるとき」=「真の最短距離が確定するとき」である．
### 最短距離を記録した頂点iに隣接する頂点を探索する
頂点`i`への最短距離`d`が記録されたとき，頂点`i`に隣接するすべての頂点`j`について，優先度付きキューに`(d+頂点iから頂点jへの距離, 頂点j)`というタプルを入れる．これは「始点から頂点番号`j`へ距離`d+頂点iから頂点jへの距離`で到達できる経路がある」とわかったからである．

## ⚡️ もっと速く！
上のアルゴリズムには無駄があるので，無駄を省くことで高速化できる
### 最短距離確定済みの頂点についてタプルを優先度付きキューに入れない
頂点`i`への最短距離`d`を記録した後，頂点`i`と頂点`j`が隣接しているとき，タプル`(d+頂点iから頂点jへの距離, 頂点j)`を優先度付きキューに追加する．しかし，このとき既に頂点`j`への最短距離が確定しているならば，このタプルは無駄になる（取り出されたときに最短距離確定済みとして捨てられる）．だったら入れなきゃいいじゃんということで，タプルを入れる前に「探索先の最短距離が確定しているか」ということをチェックし，確定していないときのみタプルを追加する．

参考
- [色々なダイクストラ高速化 - slideshare](https://www.slideshare.net/yosupo/ss-46612984)
- [ダイクストラの枝刈り高速化まとめ【python実装】- Qiita](https://qiita.com/ansain/items/8a2762446cdf2eb47759)